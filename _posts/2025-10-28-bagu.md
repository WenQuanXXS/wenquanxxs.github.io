---
title: "八股日记"
date: 2025-10-28T10:07:30-08:00
categories:
  - blog
tags:
  - Jekyll
---

# 八股

> 简单记录一下

**10.28**

- java中只有值传递
  - 传递的即使是对象，实际上也是一份拷贝，能交换数组内元素位置是因为引用参数拷贝了实际参数的地址，直接操作地址
- 序列化：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式
- 反序列化：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程
  - 序列化和反序列化发生在TCP/IP模型的应用层
- 反射让我们可以在运行时分析类以及执行类中方法，是各种框架的灵魂
  - 优点：可以访问private修饰的方法和变量，运行时加载更灵活
  - 缺点：性能开销较大，破坏了OOP的思想

**10.29**

- 乐观锁和悲观锁
  - 乐观锁倾向认为系统的共享资源很少被同时访问，只需要在提交时进行检查，无需加锁等待，但是在写冲突频繁发生时大量重写会导致cpu占用过大
  - 悲观锁倾向认为系统很有可能发生共享资源访问问题，所有共享资源在使用时都必须上锁，高并发下容易导致频繁切换上下文开销大，影响性能，以及引发死锁问题
  - 一般来说，乐观锁常用于多读少写场景，悲观锁用于多写少读场景
- 乐观锁实现？
  - 版本号检查：在数据库中加入version字段，读出数据时也读出ver值，在写回时再取出ver值比较，如果ver值变化就拒绝写操作，防止值覆盖问题
  - CAS算法：在cpu中有一个原子操作，用于更新内存中变量的值，CAS每次更新时先获取内存中变量的值作为预期值，然后开始原子操作：比较当前内存中变量的值和预期值是否相等，是则更新，这样可以防止别的线程更改过变量值

- Java中CAS的实现？
  - 调用Unsafe类中native关键字的本地方法，实现原子的操作
- CAS的问题？
  - ABA问题：如果读取的时候值是A，在当前线程阻塞和等待时变量值先后被修改成B和A，当调度到当前线程时会认为值没有被修改过
    - 解决方法：增加时间戳或者版本号机制
  - 自旋操作开销大，更新失败时会循环重试，会造成cpu开销大
    - 解决方法：引入JVM的pause指令，更新失败就暂时把线程阻塞起来
  - 只对单个变量有效
    - 解决方法：JDK新增了检查引用对象值的方法
- volatile关键字
  - 可见性：要求线程对该变量的读和写都需要在主存中进行，防止线程的本地内存造成读写问题
  - 有序性：在内存中加入屏障，禁止对变量读写语句进行排序优化
