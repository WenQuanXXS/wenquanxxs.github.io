---
title: "八股日记"
date: 2025-10-28T10:07:30-08:00
categories:
  - blog
tags:
  - Jekyll
---

# 八股

> 简单记录一下

**10.28**

- java中只有值传递
  - 传递的即使是对象，实际上也是一份拷贝，能交换数组内元素位置是因为引用参数拷贝了实际参数的地址，直接操作地址
- 序列化：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式
- 反序列化：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程
  - 序列化和反序列化发生在TCP/IP模型的应用层
- 反射让我们可以在运行时分析类以及执行类中方法，是各种框架的灵魂
  - 优点：可以访问private修饰的方法和变量，运行时加载更灵活
  - 缺点：性能开销较大，破坏了OOP的思想

**10.29**

- 乐观锁和悲观锁
  - 乐观锁倾向认为系统的共享资源很少被同时访问，只需要在提交时进行检查，无需加锁等待，但是在写冲突频繁发生时大量重写会导致cpu占用过大
  - 悲观锁倾向认为系统很有可能发生共享资源访问问题，所有共享资源在使用时都必须上锁，高并发下容易导致频繁切换上下文开销大，影响性能，以及引发死锁问题
  - 一般来说，乐观锁常用于多读少写场景，悲观锁用于多写少读场景
- 乐观锁实现？
  - 版本号检查：在数据库中加入version字段，读出数据时也读出ver值，在写回时再取出ver值比较，如果ver值变化就拒绝写操作，防止值覆盖问题
  - CAS算法：在cpu中有一个原子操作，用于更新内存中变量的值，CAS每次更新时先获取内存中变量的值作为预期值，然后开始原子操作：比较当前内存中变量的值和预期值是否相等，是则更新，这样可以防止别的线程更改过变量值

- Java中CAS的实现？
  - 调用Unsafe类中native关键字的本地方法，实现原子的操作
- CAS的问题？
  - ABA问题：如果读取的时候值是A，在当前线程阻塞和等待时变量值先后被修改成B和A，当调度到当前线程时会认为值没有被修改过
    - 解决方法：增加时间戳或者版本号机制
  - 自旋操作开销大，更新失败时会循环重试，会造成cpu开销大
    - 解决方法：引入JVM的pause指令，更新失败就暂时把线程阻塞起来
  - 只对单个变量有效
    - 解决方法：JDK新增了检查引用对象值的方法
- volatile关键字
  - 可见性：要求线程对该变量的读和写都需要在主存中进行，防止线程的本地内存造成读写问题
  - 有序性：在内存中加入屏障，禁止对变量读写语句进行排序优化

**10.30**

- 线程池参数

  - 已经实现过简单的线程池就很好理解了，核心线程数，最大线程数，任务队列（阻塞队列实现），辅助线程TTL，拒绝策略

- 常见的拒绝策略？

  - `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException`来拒绝新任务的处理
  - `ThreadPoolExecutor.CallerRunsPolicy`: 调用执行被抛弃的任务的线程重新execute，如果原线程关闭就抛弃当前任务
  - `ThreadPoolExecutor.DiscardPolicy`：不处理新任务，直接丢弃掉
  - `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求

- 线程池的原理？

  ```java
  public class MiniThreadPool {
  
      public final BlockingDeque<Runnable> blockingDeque;
      private final int CORE_POOL_SIZE;
      private final int MAX_POOL_SIZE;
      private final long TIME_OUT;
      private final TimeUnit TIME_UNIT;
      private final RejectHandle rejectHandle;
  
      public MiniThreadPool(int corePoolSize, int maxPoolSize, long timeout, TimeUnit timeUnit,
                            BlockingDeque<Runnable> blockingDeque, RejectHandle rejectHandle) {
          this.CORE_POOL_SIZE = corePoolSize;
          this.MAX_POOL_SIZE = maxPoolSize;
          this.TIME_OUT = timeout;
          this.TIME_UNIT = timeUnit;
          this.blockingDeque = blockingDeque;
          this.rejectHandle = rejectHandle;
      }
  
      List<Thread> coreThreads = new ArrayList<>();
      List<Thread> supportThreads = new ArrayList<>();
  
      public void execute(Runnable command) {
          if(coreThreads.size() < CORE_POOL_SIZE) {
              Thread thread = new CoreThread();
              coreThreads.add(thread);
              thread.start();
          }
          if(blockingDeque.offer(command)) {
              return;
          }
          if(coreThreads.size() + supportThreads.size() < MAX_POOL_SIZE) {
              Thread thread = new SupportThread();
              supportThreads.add(thread);
              thread.start();
          }
          if(!blockingDeque.offer(command)) {
              rejectHandle.reject(command,this);
          }
      }
  
      class CoreThread extends Thread {
          @Override
          public void run() {
              while (true) {
                  try {
                      Runnable command = blockingDeque.take();
                      command.run();
                  } catch (InterruptedException e) {
                      throw new RuntimeException(e);
                  }
              }
          }
      }
  
      class SupportThread extends Thread {
          @Override
          public void run() {
              while (true) {
                  try {
                      Runnable command = blockingDeque.poll(TIME_OUT, TIME_UNIT);
                      if(command == null) {
                          break;
                      }
                      command.run();
                  } catch (InterruptedException e) {
                      throw new RuntimeException(e);
                  }
              }
              System.out.println("support thread done");
          }
      }
  }
  ```

  

  - 已经实现过了，我的理解是线程池的核心对象是待执行的命令（Runnable）和执行者（Thread），命令用阻塞队列存储，可以在队列为空时阻塞线程，避免空等导致cpu资源浪费；执行者分为核心线程和辅助线程，核心线程只要被创建就不会被销毁，属于常驻线程，辅助线程在当前线程数小于任务队列大小时被创建，当任务结束后在TTL到期时自动结束

- 几个对比

  - Runnable vs Callable ：Runnable不返回值和抛出异常，Callable可以
  - Execute vs Submit ：`execute()` 方法用于提交不需要返回值的任务。通常用于执行 `Runnable` 任务，无法判断任务是否被线程池成功执行。`submit()` 方法用于提交需要返回值的任务。可以提交 `Runnable` 或 `Callable` 任务
  - shutDown vs shutDownNow：前者关闭线程池后会让队列内所有的任务执行完，后者会直接关闭线程池
